import type {
  Collection as DirectusCollection,
  Relation,
} from '@directus/shared/types'
import { useLogger } from '@nuxt/kit'

import { authentication, createDirectus, readCollections, readFields, readRelations, rest } from '@directus/sdk'
import { pascalCase } from 'change-case'
import type { Collections, Field } from './generate.types'

function warn(message: string) {
  useLogger('nuxt-directus-sdk').warn(message)
}

export interface OASOptions {
  url: string
  token: string
  prefix: string
}

// Previously used openapi-typescript but it wasn't flexible enough, this should work better?
// BASED ON: https://github.com/maltejur/directus-extension-generate-types
export async function generateTypes(options: OASOptions) {
  const collections = await getCollections(options)
  let typeValues = ''
  const types: string[] = []

  Object.values(collections).forEach((collection) => {
    const collectionName = collection.collection

    const typeName = collectionName.startsWith('directus_') ? pascalCase(collectionName) : pascalCase(`${options.prefix}${collectionName}`)
    types.push(`${collectionName}: ${typeName}[]`)
    typeValues += `export type ${typeName} = {\n`

    collection.fields.forEach((field) => {
      if (field.meta?.interface?.startsWith('presentation-'))
        return

      typeValues += '  '
      typeValues += field.field.includes('-') ? `"${field.field}"` : field.field

      if (field.schema?.is_nullable)
        typeValues += '?'

      typeValues += ': '
      typeValues += getType(field)
      typeValues += ';\n'
    })
    typeValues += '};\n\n'
  })

  // TODO: this is duplicated but can't find a good way to get the types from the generated file without using #build/types/directus.d.ts
  // And then using the same types in the end user nuxt app
  return `
  // This file is auto-generated by @nuxtjs/directus-sdk
  ${typeValues}

  export interface AllDirectusCollections {
    ${types.map(x => `  ${x};`).join('\n')}
  };

  export interface DirectusSchema {
    ${types.filter(item => !item.startsWith('directus_')).map(x => `  ${x};`).join('\n')}
  };

  declare global {
    ${typeValues.replaceAll('export type', 'type')}

    interface AllDirectusCollections {
      ${types.map(x => `  ${x};`).join('\n')}
    };

    interface DirectusSchema {
      ${types.filter(item => !item.startsWith('directus_')).map(x => `  ${x};`).join('\n')}
    };
  }

  export {};
`
}

function getType(field: Field) {
  let type: string = ''

  if (field.relation && field.relation.type === 'many') {
    type = 'any[]'
  }
  else if (field.relation) {
    type += field.relation.collection ? pascalCase(field.relation.collection) : 'any'
    if (field.relation.type === 'many')
      type += '[]'
  }
  else {
    if (['integer', 'bigInteger', 'float', 'decimal'].includes(field.type))
      type = 'number'
    else if (['boolean'].includes(field.type))
      type = 'boolean'
    else if (['json', 'csv'].includes(field.type))
      type = 'unknown'
    else type = 'string'
  }

  if (field.schema?.is_nullable) {
    if (field.relation)
      type = `${type} | null`
    else
      type += ' | null'
  }
  return type
}

export async function getCollections(options: OASOptions) {
  const directus = createDirectus(options.url)
    .with(authentication('json', { autoRefresh: false }))
    .with(rest())

  directus.setToken(options.token)

  const collections: Collections = {}

  const rawCollections: DirectusCollection[] = await directus.request(readCollections()) as any
  rawCollections
    .sort((a, b) => a.collection.localeCompare(b.collection))
    .forEach((collection) => {
      collections[collection.collection] = { ...collection, fields: [] }
    })

  const fields: Field[] = await directus.request(readFields()) as any
  fields.sort((a, b) => a.field.localeCompare(b.field))
    .forEach((field) => {
      if (!collections[field.collection]) {
        warn(`${field.collection} not found`)
        return
      }

      collections[field.collection].fields.push(field)

      if (collections[field.collection].fields.length === 0)
        delete collections[field.collection]
    })

  const relations: Relation[] = await directus.request(readRelations()) as any

  relations.forEach((relation) => {
    if (!relation.meta) {
      warn(`Relation on field '${relation.field}' in collection '${relation.collection}' has no meta. Maybe missing a relation inside directus_relations table.`)
      return
    }

    if (!relation.meta.one_collection) {
      warn('No one collection')
      return
    }

    const oneField = collections[relation.meta.one_collection]?.fields.find(field => field.field === relation.meta!.one_field)
    const manyField = collections[relation.meta.many_collection]?.fields.find(field => field.field === relation.meta!.many_field)

    if (oneField) {
      oneField.relation = {
        type: 'many',
        collection: relation.meta.many_collection,
      }
    }

    if (manyField) {
      manyField.relation = {
        type: 'one',
        collection: relation.meta.one_collection,
      }
    }
  })

  return collections
}
